# Katran
Katran是一个C ++库和BPF程序，用于构建高性能的第4层负载平衡转发平面。 Katran利用内核中的XDP基础结构来提供内核内工具，以进行快速数据包处理。

Katran 核心功能：

- 非常快（特别是在XDP驱动程序模式下）
- 性能可以通过许多NIC的RX队列线性扩展。
- RSS友好的封装。

# 安装

我们提供了一个Shell脚本，该脚本可以自动为Ubuntu 18.04构建katran。要构建和安装katran库和thrift / gRPC示例-您需要运行build_katran.sh脚本

它应该照顾所有必需的依赖项。如果需要为其他Linux发行版构建它，则需要确保

- 它可以在最新的Linux内核（4.13+）上运行
- 您已经安装
  - [folly](https://github.com/facebook/folly)
  - 最新版本的clang编译器（6.0+）
  - glog/gtest/gflags/elf libraries
  

此外，如果要构建示例代码，还必须安装fbthrift和gRPC！

# 第4层负载平衡背后的动机

4层负载平衡器（lb）可以轻松扩展第7层负载平衡器（终止TCP会话的负载平衡器）。
与其他缩放L7 lb的技术相比，L4 lb的优势在于-

- 与DNS相比，它无需等待TTL重定向来自L7 lb失败的的流量。
- 与基于任播的解决方案相比，L4 lbs在与网络相关的问题上更具弹性(触发大规模ECMP改组),
可以更好地处理从池中添加/删除L7磅的问题，并为不平等的负载平衡提供更好的支持。

# katran运行的环境要求

要使katran正常运行，有一些特殊要求。但是，
我们确实相信该library的大多数潜在用户都能轻松满足他们的需求
- katran仅在DSR（直接服务响应）模式下工作
- 网络拓扑应基于L3(机架交换机上方的所有物件均应布线),这是因为我们正在"分流"路由决策，
以便将数据包发送到真实服务器到第一路由设备
- katran不支持碎片,(它不能转发分段的数据包，如果结果数据包的大小大于MTU，也不能单独对它们进行分段)
这可以通过增加网络内的MTU或将公布的TCP MSS从17磅（即使增加了MTU，也建议这样做，因为这样可以防止某些客户端出现与碎片相关的问题）。
例如，如果不是默认的TCP MSS 1460（用于ipv4），您将公布1450-它将帮助支持PPPoE连接的客户端).
- katran不支持带有IP选项设置的数据包。
- 最大数据包大小不能大于3.5k（默认为1.5k）
- katran的构建假设是将其用于"棍子式负载均衡器”场景：
其中单个接口将用于“从用户到L4 lb（入口）”和“从L4 lb到L7 lb”的流量（出口）。"

![L4 load balancing failure scenario](https://github.com/facebookincubator/katran/raw/master/imgs/katran_pktflow.png)

由于我们仅使用数据包标头中的数据来计算哈希值，然后将其用于选择真实服务器，因此不同的L4 lbs在真实服务器选择中是一致的，
甚至没有明确的状态共享。此功能使我们可以不影响TCP会话的情况下重新启动/排空单个L4 lb，达到L7 lbs。

# katran的功能描述：

- 快速：katran使用XDP进行数据包转发，它允许在网络接口卡（NIC）接收到数据包之后，在内核有机会运行之前运行数据包处理例程（当XDP在“驱动程序模式”下工作时，katran也支持“通用XDP”操作模式（与“驱动程序”相比，性能有所下降模式“））。
- 性能随着网卡的RX队列的数量而线性扩展：XDP的工作方式是，它对每个接收到的数据包调用BPF程序，如果你的网卡有多个队列，那么每个队列的BPF程序都将独立调用。由于katran是完全无锁的，并且使用BPF映射的每cpu版本-它可以线性缩放。
- RSS友好的封装：katran使用IP IP封装从L4 lb到L7 lb的包转发。但是，为了能够在L7 lb接收端与RSS一起工作，而不是对每个ipip包使用相同的源，katran制作了一个特殊的包，这样，不同的流将具有不同的外部（ipip）源IP，但是同一流中的数据包总是有相同的。
- 固定大小（大小可在开始时配置）连接跟踪表，带有用于逐出旧项的LRU策略。
- 改进的用于连接的Maglev哈希：它在发生故障时为我们提供了良好的弹性和出色的负载平衡功能。哈希被修改为能够支持后端（L7 lbs）服务器的不等权重
- 不需要在接收路径上进行busyloping：如果没有通信服务，负载平衡器几乎不会消耗任何CPU。
- katran（通常是XDP）允许您在同一台服务器上运行任何应用程序，而不必考虑任何性能损失（与其他一些“内核旁路”技术相比）